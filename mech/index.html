<html>
<head>

<style type="text/css">
body {
	margin: 0;
}
body.debug .obstacle {
	background: red;
	opacity: .5;
	border: 1px solid white;
}
#ground {
	background: url(bg.jpg) 0 0 repeat #553;
	width: 3840px;
	height: 2160px;
}
#cam {
	transition: all 67ms linear;
	position: relative;
}
#p1 {
	width: 50px;
	height: 70px;
	background-position: center;
	transition: all 67ms linear;
	position: absolute;
	border: 0px solid blue;
}
#p1::before {
	content: " ";
	width: 120px;
	height: 110px;
	margin: -15px 0 0 -45px;
	display: block;
	background-size: contain;
	background-position: center center;
	background-repeat: no-repeat;
}
#p1.right::before {
	background-image: url(standing.gif);
	transform: rotate(-17deg);
}
#p1.right.walk::before {
	background-image: url(2-warhawka.gif);
	transform: rotate(-17deg);
}

#p1.left::before {
	background-image: url(standing.gif);
	transform: scaleX(-1) rotate(-17deg);
}
#p1.left.walk::before {
	background-image: url(2-warhawka.gif);
	transform: scaleX(-1) rotate(-17deg);
}

#p1.down::before {
	background-image: url(standing-down.gif);
}
#p1.down.walk::before {
	background-image: url(warhawk-down2.gif);
}

#p1.up::before {
	background-image: url(standing-up.png);
}
#p1.up.walk::before {
	background-image: url(warhawk-up-frames-no-shadow.gif);
}


.turret {
	position: absolute;
	background: url(turret-up-left.png) center center no-repeat;
	background-size: contain;
	width: 99px;
	height: 87px;
}
.turret.top.left {
	background-image: url(turret-up-left.png);
}
.turret.top.right {
	background-image: url(turret-up-right.png);
}
.turret.bottom.left {
	background-image: url(turret-down-left.png);
}
.turret.bottom.right {
	background-image: url(turret-down-right.png);
}



.erppc {
	display: block;
	position: absolute;
	width: 20px;
	height: 20px;
	background: url(erppc.gif) 0 0 no-repeat;
	background-size: contain;
}
.erppc.explosion {
	background: none;
}
.erppc.explosion::before {
	content: " ";
	display: block;
	width: 60px;
	height: 120px;
	margin: -60px 0 0 -15px;
	background: url(explosion.gif) 0 0 no-repeat;
	background-size: contain;
}
.erppc.explosion.fade::before {
	animation-name: explosionDissipation;
    animation-duration: 1000ms;
}

.missile {
	transition: all 300ms linear;
	position: absolute;
	width: 15px;
	height: 75px;
	background: url(missile.gif) 0 0 no-repeat;
	background-size: contain;
}
.missile.explosion {
	background: none;
}
.missile.explosion::before {
	content: " ";
	display: block;
	width: 60px;
	height: 120px;
	margin: 0 0 0 -15px;
	background: url(explosion.gif) 0 0 no-repeat;
	background-size: contain;
}
.missile.explosion.fade::before {
	animation-name: explosionDissipation;
    animation-duration: 1000ms;
}


@keyframes explosionDissipation {
	0% {
		opacity: 1;
	}
	50% {
		opacity: 0.5;
	}
	100% {
		display: none;
		opacity: 0;
	}
}
</style>

<script type="text/javascript" src="https://code.jquery.com/jquery-1.8.3.js"></script>
<script type="text/javascript">
var p1, ground, global_ground_width, global_ground_height;
var global_increment_by = 10;
var global_box_size = 50;
var global_player_height = 70;
var global_window_size = window.innerWidth;
var direction = 'right';
var fireArray = new Array();


document.addEventListener("DOMContentLoaded", function(event) { 
	p1		= document.getElementById("p1");
	ground	= document.getElementById("ground");
	cam		= document.getElementById("cam");

	p1.style.marginLeft	= "30px";
	p1.style.marginTop = "30px";
	cam.style.width = getWindowWidth();
	cam.style.height = getWindowHeight();
	setInterval("rotateTurrets()", 1000);
	setInterval("promptEnemiesToFire()", 1000);
	debug();
});


function debug() {
	if (location.search.includes("debug")) {
		document.body.classList.add("debug");
	}
}

function getWindowWidth() {
	return global_window_size;
}

function getWindowHeight() {
	return window.innerHeight;
}

function getGroundWidth() {
	if (!global_ground_width) {
		var ground = document.getElementById("ground");
		var groundOffset = ground.getBoundingClientRect();
		var groundWidth = groundOffset.width ? parseInt(groundOffset.width) : 0;
		global_ground_width = groundWidth;
	}
	return global_ground_width;
}

function getGroundHeight() {
	if (!global_ground_height) {
		var ground = document.getElementById("ground");
		var groundOffset = ground.getBoundingClientRect();
		var groundHeight = groundOffset.height ? parseInt(groundOffset.height) : 0;
		global_ground_height = groundHeight;
	}
	return global_ground_height;
}



var downTimer;
var lastKey;
$(document).ready(function() {
	$(document.body).keydown(function(e) {
		if (e.keyCode == '32') {
			fire(p1, "good", "erppc");
			return false;
		}
		if (!isMovingKey(e.keyCode)) {
			return;
		}

	    // if not still the same key, stop the timer
	    if (e.which !== lastKey) {
	        if (downTimer) {
	            clearInterval(downTimer);
	            downTimer = null;
	        }
	    }
	    // remember previous key
	    lastKey = e.which;
	    if (!downTimer) {
	        // start timer
	        downTimer = setInterval(function() {
	            if (e.which == 37) {
	            	if (!p1.classList.contains("walk")) {
		            	p1.classList.add("walk");
		            }
		            if (!playerObstacles(p1,"left")) {
		            	moveCamLeft(p1);
		            	moveBlockLeft(p1, true);
		            }
	            	changeDirection(p1, "left");
	            } else if (e.which == 38) {
	            	if (!p1.classList.contains("walk")) {
		            	p1.classList.add("walk");
		            }
		            if (!playerObstacles(p1,"up")) {
		            	moveCamUp(p1);
		            	moveBlockUp(p1, true);
		            }
	            	changeDirection(p1, "up");
	            } else if (e.which == 39) {
	            	if (!p1.classList.contains("walk")) {
		            	p1.classList.add("walk");
		            }
	            	if (!playerObstacles(p1,"right")) {
	            		moveCamRight(p1);
		            	moveBlockRight(p1, true);
		            }
	            	changeDirection(p1, "right");
	            } else if (e.which == 40) {
	            	if (!p1.classList.contains("walk")) {
		            	p1.classList.add("walk");
		            }
		            if (!playerObstacles(p1,"down")) {
		            	moveCamDown(p1);
		            	moveBlockDown(p1, true);
		            }
	            	changeDirection(p1, "down");
	            } else {
	            	//
	            }
	        }, 67);
	    }
	    return false;
	}).keyup(function(e) {
		if (isMovingKey(e.keyCode)) {
			p1.classList.remove("walk");
		    // stop timer
		    if (downTimer) {
		        clearInterval(downTimer);
		        downTimer = null;
		        lastKey = 0;
		    }
		}
	});

});

/* Is this left, up, right, down key */
function isMovingKey(k) {
	if (k == "37" || k == "38" || k == "39" || k == "40") {
		return true;
	}
	return false;
}

function playerObstacles(player, direction) {
	obstacles = document.getElementsByClassName("obstacle");
	enemies = document.getElementsByClassName("enemy");
	var allObstacles = [...obstacles, ...enemies];
	for (i = 0; i < allObstacles.length; i++) {
		if (willBlocksOverlap(player, allObstacles[i], direction)) {
			//console.log("player x end: " + (parseInt(player.style.marginLeft) + 50 + global_increment_by));
			//console.log("allObstacles[" + i + "].marginLeft: " + parseInt(allObstacles[i].style.marginLeft));
			return true;
		}
	}
	return false;
}



function moveBlockLeft(block, windowBoundary = false, increment = global_increment_by) {
	var marginLeft = block.style.marginLeft ? parseInt(block.style.marginLeft) : 0;
	var newMarginLeft = marginLeft - increment;
	if (newMarginLeft >= 0 || !windowBoundary) {
		block.style.marginLeft = newMarginLeft + "px";
	}
}
function moveBlockRight(block, windowBoundary = false, increment = global_increment_by) {
	var marginLeft = block.style.marginLeft ? parseInt(block.style.marginLeft) : 0;
	var newMarginLeft = marginLeft + increment;
	if (newMarginLeft <= (getGroundWidth() - global_box_size) || !windowBoundary) {
		block.style.marginLeft = newMarginLeft + "px";
	}
}
function moveBlockUp(block, windowBoundary = false, increment = global_increment_by) {
	var marginTop = block.style.marginTop ? parseInt(block.style.marginTop) : 0;
	var newMarginTop = marginTop - increment;
	if (newMarginTop >= 0 || !windowBoundary) {
		block.style.marginTop = newMarginTop + "px";
	}
}
function moveBlockDown(block, windowBoundary = false, increment = global_increment_by) {
	var marginTop = block.style.marginTop ? parseInt(block.style.marginTop) : 0;
	var newMarginTop = marginTop + increment;
	if (newMarginTop <= (getGroundHeight() - global_box_size) || !windowBoundary) {
		block.style.marginTop = newMarginTop + "px";
	}
}

// addMargin is to look in the future
function doBlocksOverLap(box1, box2) {
	var box1viewportOffset = box1.getBoundingClientRect();
	var box1XStart	= box1viewportOffset.x ? parseInt(box1viewportOffset.x) : 0;
	var box1XEnd 	= box1XStart + box1viewportOffset.width;
	var box1YStart	= box1viewportOffset.y ? parseInt(box1viewportOffset.y) : 0;
	var box1YEnd	= box1YStart + box1viewportOffset.height;

	var box2viewportOffset = box2.getBoundingClientRect();
	var box2XStart	= box2viewportOffset.x ? parseInt(box2viewportOffset.x) : 0;
	var box2XEnd 	= box2XStart + box2.getBoundingClientRect().width;
	var box2YStart	= box2viewportOffset.y ? parseInt(box2viewportOffset.y) : 0;
	var box2YEnd	= box2YStart + box2.getBoundingClientRect().height;

	var xOverLapStart = (box1XStart >= box2XStart && box1XStart <= box2XEnd);
	var xOverLapEnd = (box1XEnd >= box2XStart && box1XEnd <= box2XEnd);
	var yOverLapStart = (box1YStart >= box2YStart && box1YStart <= box2YEnd);
	var yOverLapEnd = (box1YEnd >= box2YStart && box1YEnd <= box2YEnd);
	if ((yOverLapStart || yOverLapEnd) && (xOverLapStart || xOverLapEnd)) {
		return true;
	} else {
		return false;
	}
}
function willBlocksOverlap(box1, box2, direction) {
	paddingHorizontal	= 0;
	paddingVertical		= 0;
	if (direction == "left") {
		paddingHorizontal = paddingHorizontal - global_increment_by;
	}
	if (direction == "right") {
		paddingHorizontal = paddingHorizontal + global_increment_by;
	}
	if (direction == "up") {
		paddingVertical = paddingVertical - global_increment_by;
	}
	if (direction == "down") {
		paddingVertical = paddingVertical + global_increment_by;
	}
	//console.log("box1XEnd = " + box1XEnd);
	var box1viewportOffset = box1.getBoundingClientRect();
	var box1XStart	= (box1viewportOffset.x ? parseInt(box1viewportOffset.x) : 0) + paddingHorizontal;
	var box1XEnd 	= box1XStart + box1viewportOffset.width + paddingHorizontal;
		//console.log("box1XEnd = " + box1XEnd);
	var box1YStart	= (box1viewportOffset.y ? parseInt(box1viewportOffset.y) : 0) + paddingVertical;
	var box1YEnd	= box1YStart + box1viewportOffset.height + paddingVertical;

	var box2viewportOffset = box2.getBoundingClientRect();
	var box2XStart	= box2viewportOffset.x ? parseInt(box2viewportOffset.x) : 0;
	var box2XEnd 	= box2XStart + box2.getBoundingClientRect().width;
	var box2YStart	= box2viewportOffset.y ? parseInt(box2viewportOffset.y) : 0;
	var box2YEnd	= box2YStart + box2.getBoundingClientRect().height;

	var xOverLapStart = (box1XStart >= box2XStart && box1XStart <= box2XEnd);
	var xOverLapEnd = (box1XEnd >= box2XStart && box1XEnd <= box2XEnd);
	var yOverLapStart = (box1YStart >= box2YStart && box1YStart <= box2YEnd);
	var yOverLapEnd = (box1YEnd >= box2YStart && box1YEnd <= box2YEnd);
	if ((yOverLapStart || yOverLapEnd) && (xOverLapStart || xOverLapEnd)) {
		//console.log("true");
		return true;
	} else {
		//console.log("false");
		return false;
	}
}

function changeDirection(obj, dir) {
	obj.classList.remove("left", "up", "right", "down");
	obj.classList.add(dir);
	if (obj.id == "p1") {
		obj.dataset.direction = dir;
		direction = dir;
	}
}


function turretDirection(turret) {
	var p1Details = p1.getBoundingClientRect();
    var p1x	= p1Details.x;
    var p1y	= p1Details.y;

    var turretDetails = turret.getBoundingClientRect();
    var tx = turretDetails.x;
    var ty = turretDetails.y;

    if (p1x < tx) {
    	turret.classList.remove("right");
    	turret.classList.add("left");
    	turret.dataset.direction = "left";
    } else {
    	turret.classList.remove("left");
    	turret.classList.add("right");
    	turret.dataset.direction = "right";
    }
    if (p1y < ty) {
    	turret.classList.remove("bottom");
    	turret.classList.add("top");
    	turret.dataset.direction = "up";
    } else {
    	turret.classList.remove("top");
    	turret.classList.add("bottom");
    	turret.dataset.direction = "down";
    }
}


function rotateTurrets() {
	var turrets = document.getElementsByClassName("turret");
	for (i = 0; i < turrets.length; i++) {
		turretDirection(turrets[i]);
	}
}


function fire(gunner, allegiance, projectileType) {
	var fireStartX	= gunner.style.marginLeft ? parseInt(gunner.style.marginLeft) : 0;
		fireStartX	= fireStartX + 15;
	var fireStartY	= gunner.style.marginTop ? parseInt(gunner.style.marginTop) : 0;
		fireStartY	= fireStartY + 25;
	var projectile = document.createElement("div");
		var rando = Math.random();
		projectile.setAttribute("class", projectileType);
		projectile.setAttribute("id", "projectile" + rando);
		projectile.setAttribute("data-allegiance", allegiance);
		ground.appendChild(projectile);
		document.getElementById("projectile" + rando).style.marginLeft = fireStartX;
		document.getElementById("projectile" + rando).style.marginTop = fireStartY;
	var dir = gunner.dataset.direction;
	fireArray.push("projectile" + rando);
	if (projectileType == "erppc") {
		fireERPPC("projectile" + rando, dir);
	} else {
		fireMissile("projectile" + rando, dir);
	}
}

function fireERPPC(firedArrayElm, dir) {
	fireArray[firedArrayElm] = setInterval(function() {
		projectile = document.getElementById(firedArrayElm);
		if (projectile) {
			hitAllegiance = (projectile.dataset.allegiance == "good") ? "enemy" : "good";
			checkProjectileHittingObject(firedArrayElm, hitAllegiance);
			checkProjectileHittingObject(firedArrayElm, "obstacle");
			switch(dir) {
				case "right" : moveBlockRight(projectile); break;
				case "left" : moveBlockLeft(projectile); break;
				case "up" : moveBlockUp(projectile); break;
				case "down" : moveBlockDown(projectile); break;
				default : "";break;
			}
			
		}
	},20);

	// begin fade out animation
	setTimeout(function() {
		clearInterval(fireArray[firedArrayElm]);
		elm = document.getElementById(firedArrayElm);
		if (elm && elm.classList.contains("explosion")) {
			elm.classList.add("fade");
		}
		if (elm && !elm.classList.contains("explosion")) {
			elm.remove();
		} else {
			// clear item after explosion animation
			setTimeout(function() {
				if (document.getElementById(firedArrayElm)) {
					document.getElementById(firedArrayElm).remove();
				}
			}, 1000);
		}
	}, 3000);
}

function fireMissile(firedArrayElm, dir) {
	projectile = document.getElementById(firedArrayElm);
	hitAllegiance = (projectile.dataset.allegiance == "good") ? "enemy" : "good";
	var nearestFoe = getNearestAllegiance(projectile, hitAllegiance);
	var directionDetails = homingDirection(projectile, nearestFoe);
		x = directionDetails[0];
		y = directionDetails[1];
		xDir = directionDetails[2];
		yDir = directionDetails[3];
		diff = directionDetails[4];
	pointProjectile(projectile, directionDetails);
	fireArray[firedArrayElm] = setInterval(function() {
		if (projectile) {
			hitAllegiance = (projectile.dataset.allegiance == "good") ? "enemy" : "good";
			checkProjectileHittingObject(firedArrayElm, hitAllegiance);
			checkProjectileHittingObject(firedArrayElm, "obstacle");
			if (xDir == "left") {
				moveBlockLeft(projectile, false, 50);
			} else if (xDir == "right") {
				moveBlockRight(projectile, false, 50);
			}
			if (yDir == "up") {
				moveBlockUp(projectile, false, Math.abs(50/diff));
			} else if (yDir == "down") {
				moveBlockDown(projectile, false, Math.abs(50/diff));
			}
		}
	},300);

	// begin fade out animation
	setTimeout(function() {
		clearInterval(fireArray[firedArrayElm]);
		elm = document.getElementById(firedArrayElm);
		if (elm && elm.classList.contains("explosion")) {
			elm.classList.add("fade");
		}
		if (elm && !elm.classList.contains("explosion")) {
			elm.remove();
		} else {
			// clear item after explosion animation
			setTimeout(function() {
				if (document.getElementById(firedArrayElm)) {
					document.getElementById(firedArrayElm).remove();
				}
			}, 1000);
		}
	}, 3000);
}

function getNearestAllegiance(projectile, hitAllegiance) {
	// TODO: math to find nearest foe (enemy or good guy)
	return p1;
}

function homingDirection(projectile, nearestFoe) {
	var projectileDetails = projectile.getBoundingClientRect();
	var nearestFoeDetails = nearestFoe.getBoundingClientRect();
	var x = projectileDetails.x - nearestFoeDetails.x;
	var y = projectileDetails.y - nearestFoeDetails.y;
	var xDir = (projectileDetails.x > nearestFoeDetails.x) ? "left" : "right";
	var yDir = (projectileDetails.y > nearestFoeDetails.y) ? "up" : "down";
	var diff = x / y;
	console.log("x = " + x + " y = " + y + " xDir = " + xDir + " yDir = " + yDir + " diff = " + diff);
	return [x, y, xDir, yDir, diff];
}

/*
Intended to get rotate projectile correctly
*/
function pointProjectile(projectile, projectileDetails) {
	x = projectileDetails[0];
	y = projectileDetails[1];
	xDir = projectileDetails[2];
	yDir = projectileDetails[3];
	diff = projectileDetails[4];
	rotateAngle = 0;
	if (xDir == "right" && yDir == "up") {
		rotateAngle = diff * 180/Math.PI;
	}
	console.log("transform: rotate(" + rotateAngle + "deg)")
	//projectile.setAttribute("style", "transform: rotate(" + rotateAngle + "deg)");
}


/*
projectileArrayElm = array key of fired element
hitType = obstacle such as building, or enemy
*/
function checkProjectileHittingObject(projectileArrayElm, hitType) {
	projectile = document.getElementById(projectileArrayElm);
	if (hitType == 'obstacle') {
		obstacles = document.getElementsByClassName("obstacle");
	} else {
		obstacles = document.querySelectorAll("[data-allegiance='" + hitType + "']");
	}
	for (i = 0; i < obstacles.length; i++) {
		var friendlyFire = false;
		if (obstacles[i].dataset?.allegiance == projectile.dataset?.allegiance) {
			friendlyFire = true;
		}
		//console.log("obstacles[i].dataset?.allegiance = " + obstacles[i].dataset?.allegiance)
		//console.log("projectile.dataset?.allegiance = " + projectile.dataset?.allegiance)
		if (doBlocksOverLap(projectile, obstacles[i]) && !friendlyFire) {
			//console.log("hit");
			clearInterval(fireArray[projectileArrayElm]);
			convertToExplosion(projectile);
			return true;
		}
	}
	return false;
}

function promptEnemiesToFire() {
	var enemies = document.getElementsByClassName("enemy");
	for (var i = 0; i < enemies.length; i++) {
		if (enemyWithinRange(enemies[i])) {
			makeEnemyFire(enemies[i]);
		}
	}
}

function enemyWithinRange(enemy) {
	var inRange = 1000;
	var enemeyDetails = enemy.getBoundingClientRect();
	var enemyX = enemeyDetails.x + (enemeyDetails.width / 2);
	var enemyY = enemeyDetails.y + (enemeyDetails.height / 2);

	var p1Details = p1.getBoundingClientRect();
	var p1X = p1Details.x + (p1Details.width / 2);
	var p1Y = p1Details.y + (p1Details.height / 2);

	var withinX = (p1X - enemyX < inRange && p1X - enemyX > -Math.abs(inRange));
	var withinY = (p1Y - enemyY < inRange && p1Y - enemyY > -Math.abs(inRange));
	
	if (withinX && withinY) {
		return true;
	}
	return false;
}

function makeEnemyFire(enemy) {
	var rando = Math.random() * 3000;
	// every 1/3
	if (rando <= 1000) {
		//console.log("FIRE! " + enemy)
		fire(enemy, "enemy", "missile");
	}
}



/* converts a fired ammo into a 'hit' */
function convertToExplosion(fire) {
	fire.classList.add("explosion");
}



function moveCamRight(p1){
    var cam_center = getWindowWidth() / 2 - global_box_size;
    var groundDetails = ground.getBoundingClientRect();
    var groundWidth	= groundDetails.width;
    var maxLeft = groundWidth - getWindowWidth();
    var p1marginLeft = parseInt(p1.style.marginLeft);
    if (!p1marginLeft) {
        p1marginLeft = 0;
    }
    var cam = document.getElementById("cam");
    var cam_marginLeft = parseInt(cam.style.marginLeft);
    if (!cam_marginLeft) {
        cam_marginLeft = 0;
    }
    //console.log("cam_marginLeft = " + cam_marginLeft + "; maxLeft = " + maxLeft);
    if (p1marginLeft>=cam_center && Math.abs(cam_marginLeft) < maxLeft){
        var new_cam_marginLeft = cam_marginLeft - global_increment_by;
        cam.style.marginLeft = new_cam_marginLeft + "px";
    }
}
function moveCamLeft(p1){
    var cam_center = getWindowWidth() / 2 - global_box_size;
    var groundDetails = ground.getBoundingClientRect();
    var groundWidth	= groundDetails.width;
    var p1marginLeft = parseInt(p1.style.marginLeft);
    if (!p1marginLeft) {
        p1marginLeft = 0;
    }
    var maxLeft = groundWidth - getWindowWidth() + cam_center; // when player is at right-most and goes left
    var cam = document.getElementById("cam");
    var cam_marginLeft = parseInt(cam.style.marginLeft);
    if (!cam_marginLeft) {
        cam_marginLeft = 0;
    }
    //console.log("p1marginLeft = " + p1marginLeft + "; maxLeft = " + maxLeft);
    if (p1marginLeft>=cam_center && Math.abs(p1marginLeft) < maxLeft){
        var new_cam_marginLeft = cam_marginLeft + global_increment_by;
        if (new_cam_marginLeft > 0) {new_cam_marginLeft=0;}
        cam.style.marginLeft = new_cam_marginLeft + "px";
    }
}
function moveCamUp(p1){
    var cam_center = getWindowHeight() / 2 - global_box_size;
    var groundDetails = ground.getBoundingClientRect();
    var groundHeight	= groundDetails.height;
    var maxHeight = Math.floor((groundHeight - getWindowHeight() + cam_center) / 10) * 10;
    var p1marginTop = parseInt(p1.style.marginTop);
    if (!p1marginTop) {
        p1marginTop = 0;
    }
    var cam = document.getElementById("cam");
    var cam_marginTop = parseInt(cam.style.marginTop);
    if (!cam_marginTop) {
        cam_marginTop = 0;
    }
    if (p1marginTop>=cam_center && Math.abs(p1marginTop) < maxHeight){
        var new_cam_marginTop = cam_marginTop + global_increment_by;
        cam.style.marginTop = new_cam_marginTop + "px";
    }
}
function moveCamDown(p1){
    var cam_center = getWindowHeight() / 2 - global_player_height;
    var groundDetails = ground.getBoundingClientRect();
    var groundHeight	= groundDetails.height;
    var maxHeight = Math.floor((groundHeight - getWindowHeight()) / 10) * 10;
    var p1marginTop = parseInt(p1.style.marginTop);
    if (!p1marginTop) {
        p1marginTop = 0;
    }
    var cam = document.getElementById("cam");
    var cam_marginTop = parseInt(cam.style.marginTop);
    if (!cam_marginTop) {
        cam_marginTop = 0;
    }
    //console.log("cam_marginTop = " + Math.abs(cam_marginTop) + "; maxHeight = " + maxHeight);
    if (p1marginTop>=cam_center && Math.abs(cam_marginTop) < maxHeight){
        var new_cam_marginTop = cam_marginTop - global_increment_by;
        cam.style.marginTop = new_cam_marginTop + "px";
    }
}
</script>


</head>
<body>
<div id="cam">
	<div id="ground">
		<div id="p1" class="right" data-allegiance="good" data-direction="right"></div>

		<div class="turret enemy" data-allegiance="enemy" data-direction="left" style="margin: 150px 0 0 150px"></div>
		<!-- <div class="turret enemy" data-allegiance="enemy" data-direction="left" style="margin: 350px 0 0 350px"></div> -->

		<div style="position: absolute;
		margin-top: 0;
		margin-left: 1530px;
		width: 831px;
		height: 286px;" class="obstacle" data-allegiance="obstacle"></div>

			<div style="position: absolute;
		margin-top: 0;
		margin-left: 1300px;
		width: 250px;
		height: 150px;" class="obstacle" data-allegiance="obstacle"></div>
		
		<div style="position: absolute;
		margin-top: 250px;
		margin-left: 2100px;
		width: 390px;
		height: 350px;" class="obstacle" data-allegiance="obstacle"></div>
		
		<div style="position: absolute;
		margin-top: 250px;
		margin-left: 1923px;
		width: 190px;
		height: 230px;" class="obstacle" data-allegiance="obstacle"></div>
		
		<div style="position: absolute;
		margin-top: 1000px;
		margin-left: 0;
		width: 364px;
		height: 230px;" class="obstacle" data-allegiance="obstacle"></div>
		
		<div style="position: absolute;
		margin-top: 1159px;
		margin-left: 318px;
		width: 173px;
		height: 144px;" class="obstacle" data-allegiance="obstacle"></div>

	</div>
</div>
</body>
</html>
