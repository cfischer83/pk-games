<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet" />

<title>Dragon Side-Scroller</title>
<style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
	font-family: 'Press Start 2P', 'Helvetica Neue', Helvetica, Sans-serif;
}

body {
    overflow: hidden;
    font-family: monospace;
    background: #000;
}

#game-container {
    position: relative;
    width: 100vw;
    height: 100vh;
	background: url(img/planet.png) calc(100% - 250px) 0 no-repeat, url(img/stars.png) top repeat-x #000;
}

#viewport {
    position: absolute;
    width: 100%;
    height: 100%;
    overflow: hidden;
}

.parallax-layer {
    position: absolute;
    width: 500%;
    height: 100%;
    image-rendering: pixelated;
}

#stars {
    background: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAAEklEQVQIHWNgYGD4z8DAwMAAAAAA//8DABuFAnoAAAAASUVORK5CYII=') repeat;
    opacity: 0.7;
}

#far-mountains {
    bottom: 10%;
    height: 40%;
    background: url(img/mountains.png) bottom left repeat-x;
}

#near-mountains {
    bottom: 10%;
    height: 30%;
	min-height: 134px;
	background: url(img/midlands.png) bottom left repeat-x;
}

#ground {
    position: absolute;
    bottom: 0;
    width: 1300%;
    height: 10%;
    background: url(img/ground.png) top left repeat;
}

#world {
    position: absolute;
    width: 100%;
    height: 100%;
}

.sprite {
    position: absolute;
    image-rendering: pixelated;
    transform-origin: center bottom;
    background-repeat: no-repeat;
}

#dragon1 {
    z-index: 10;
}

#dragon1-upper {
    position: absolute;
    z-index: 11;
    background-repeat: no-repeat;
    image-rendering: pixelated;
    pointer-events: none;
    display: none;
}

#dragon2 {
    z-index: 15;
}

.enemy {
    z-index: 8;
}

.projectile {
    z-index: 9;
}

.obstacle {
    z-index: 7;
}

.fire-beam {
    z-index: 12;
}

.lightning-bolt {
    z-index: 13;
    background: linear-gradient(90deg,
        rgba(200, 200, 255, 0.9) 0%,
        rgba(255, 255, 255, 1) 50%,
        rgba(200, 200, 255, 0.9) 100%);
    box-shadow: 0 0 30px #8888ff, 0 0 60px #6666ff;
    animation: lightning-flash 0.3s infinite;
}

@keyframes fire-pulse {
    0%, 100% { opacity: 0.9; }
    50% { opacity: 1; }
}

@keyframes lightning-flash {
    0%, 100% { opacity: 0.8; }
    50% { opacity: 1; }
}

.bird {
    width: 42px;
    height: 30px;
}

.tank {
    width: 64px;
    height: 32px;
    background: url(img/tank.png) left bottom no-repeat;
}

.rock {
    width: 64px;
    height: 96px;
    background: url(img/rocks.png) bottom left no-repeat;
}
.rock.broken {
    width: 64px;
    height: 96px;
    background: url(img/rocks.png) bottom right no-repeat;
}

.bullet {
    width: 12px;
    height: 6px;
    background: #ffff00;
    border-radius: 50%;
    box-shadow: 0 0 10px #ffff00;
}

#hud {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    padding: 20px;
    z-index: 100;
    pointer-events: none;
}

.health-bar {
    display: inline-block;
    width: 200px;
    height: 20px;
    background: #222;
    border: 2px solid #fff;
    position: relative;
}

.health-fill {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    background: #F00;
    transition: width 0.3s;
}

.cooldown-bar {
    display: inline-block;
    width: 200px;
    height: 20px;
    background: #222;
    border: 2px solid #fff;
    position: relative;
}

.cooldown-fill {
    position: absolute;
    top: 0;
    left: 0;
    height: 100%;
    background: #08F;
    transition: width 0.1s;
}

#boss-health {
    position: absolute;
    top: 20px;
    right: 20px;
    display: none;
}

#menu {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: #212121;
    padding: 40px;
    text-align: center;
    color: #fff;
    z-index: 200;
    font-size: 18px;
}

#menu h1 {
    font-size: 36px;
    margin-bottom: 30px;
    color: #ffcc00;
    text-shadow: 2px 2px 4px #000;
}

#menu button {
    font-size: 24px;
    padding: 15px 40px;
    margin: 20px 0;
    background: #0f1554;
    border: 2px solid #ae3314;
    color: #2f8000;
    cursor: pointer;
    text-shadow: 1px 1px 2px #000;
    transition: transform 0.2s;
}

#menu button:hover {
    transform: scale(1.1);
}

.controls {
    margin-top: 30px;
    text-align: left;
    font-size: 14px;
	line-height: 18px;
	font-weight: 100;
	font-family:'Courier New', Courier, monospace;
}
.controls .uni {
	font-family: "Helvetica Neue", "Helvetica", Helvetica, Arial, sans-serif;
}

#debug {
    position: absolute;
    top: 80px;
    left: 20px;
    color: #0f0;
    font-size: 12px;
    z-index: 150;
    display: none;
}

.hitbox {
    position: absolute;
    border: 2px solid rgba(255, 0, 0, 0.5);
    pointer-events: none;
    z-index: 50;
}

.hurtbox {
    position: absolute;
    border: 2px solid rgba(0, 255, 0, 0.5);
    pointer-events: none;
    z-index: 50;
}

/* Debug mode - show hitboxes */
body.debug-mode #dragon1,
body.debug-mode #dragon1-upper,
body.debug-mode #dragon2,
body.debug-mode .enemy,
body.debug-mode .projectile,
body.debug-mode .obstacle {
    outline: 2px solid red !important;
    outline-offset: -2px;
}

body.debug-mode #dragon1 {
    outline-color: lime !important;
}

body.debug-mode #dragon2 {
    outline-color: orange !important;
}
</style>
</head>
<body>
<div id="game-container">
    <div id="viewport">
        <div class="parallax-layer" id="stars"></div>
        <div class="parallax-layer" id="far-mountains"></div>
        <div class="parallax-layer" id="near-mountains"></div>
        <div id="ground"></div>
        <div id="world">
            <div id="dragon1" class="sprite" 
                data-upper="stand" 
                data-lower="stand" 
                data-facing="right" 
                data-frame="0" 
                data-attack="none"
                data-can-fire="true"></div>
            <div id="dragon1-upper" class="sprite"></div>
        </div>
    </div>
    
    <div id="hud">
        <div>
            <span style="color: #fff; width: 100px; display: inline-block;">HP:</span>
            <div class="health-bar">
                <div class="health-fill" id="player-health"></div>
            </div>
			<br /><br />
            <span style="color: #fff; width: 100px; display: inline-block;">Fire:</span>
            <div class="cooldown-bar">
                <div class="cooldown-fill" id="fire-cooldown"></div>
            </div>
        </div>
        <div id="boss-health">
            <span style="color: #fff; text-shadow: 2px 2px 2px #000,2px 2px 2px #000,2px 2px 2px #000">BOSS: </span>
            <div class="health-bar">
                <div class="health-fill" id="boss-health-fill"></div>
            </div>
        </div>
    </div>

    <div id="menu">
        <img src="img/menu.png" width="427"><br />
        <button onclick="startGame()">START GAME</button>
        <div class="controls">
            CONTROLS:<br>
            <span class="uni"> &#x21e6; &#x21e8;</span> Arrow keys to walk<br>
			<span class="uni"> &#x21e7;</span> - Jump<br>
            <span class="uni"> &#x21e9;</span> or C - Duck<br>
            Z - Punch<br>
            X - Kick<br>
            [Space] - Fire (or Tail Spin while ducking)<br><br>
        </div>
    </div>

    <div id="debug"></div>
</div>

<script src="dragon-sprites.js"></script>
<script>
// Configuration
const GAME_CONFIG = {
    level: { 
        gateX: 15500, 
        groundBandPct: 0.10 
    },
    speed: { 
        min: 110, 
        base: 130, 
        max: 150, 
        ramp: { 
            enabled: true, 
            early: 0, 
            mid: 10, 
            late: 20 
        } 
    },
    physics: { 
        targetApexFactor: 0.75, 
        timeToApexMs: 450, 
        coyoteMs: 120, 
        jumpBufferMs: 120, 
        terminalVy: 1400 
    },
    animation: {
        frameDuration: .1  // Duration per frame in seconds (0.1 = 10 FPS, 0.05 = 20 FPS, etc.)
    },
    fire: { 
        windupMs: 500, 
        activeMs: 1500, 
        cooldownMs: 7000, 
        tickMs: 300, 
        beamSize: { w: 216, h: 102 }, 
        mouthOffset: { fromTop: 55, fromRight: 20 }, 
        scale: 1 
    },
    tail: { 
        risePx: 70, 
        scale: 1, 
        activeMs: 600  // 6 frames Ã— 100ms per frame
    },
    hp: { 
        player: 50, 
        boss: 50, 
        bird: 1, 
        tank: 2, 
        rock: 6
    },
    damage: { 
        punch: 1, 
        kick: 2, 
        tail: 3, 
        fire: 5, 
        birdContact: 1, 
        tankBullet: 2, 
        bossBody: 1, 
        bossLightning: 4 
    },
    spawn: { 
        maxEnemies: 5,
        maxObstacles: 15,  // Allow more obstacles (rocks) than enemies
        minSpacingRule: 'dragonWidth',
        schedule: [
            { start: 0, end: 20, enemies: ['tank', 'bird'], intervals: [7000], max: 2 },
            { start: 20, end: 80, enemies: ['bird', 'tank'], intervals: [6000, 9500], max: 3 },
            { start: 80, end: 110, enemies: ['bird', 'tank'], intervals: [4500, 7500], max: 4 }
        ],
        obstacleSchedule: [
            { start: 0, end: 20, interval: 2000 },   // Rock every 2 seconds early game
            { start: 20, end: 80, interval: 1500 },  // More frequent mid game
            { start: 80, end: 110, interval: 1200 }  // Even more frequent late game
        ]
    },
    camera: { 
        lookAheadPx: 80 
    }
};

// Sprite data (ANCHORS_JSON, getFrameInfo, applySpriteFrame) loaded from dragon-sprites.js

// Game state
let game = {
    running: false,
    won: false,
    lost: false,
    time: 0,
    lastTime: 0,
    accumulator: 0,
    fixedDeltaMs: 1000 / 60,
    
    player: {
        x: 100,
        y: 0,
        vx: 0,
        vy: 0,
        width: 142,
        height: 128,
        facing: 'right',
        grounded: false,
        hp: GAME_CONFIG.hp.player,
        maxHp: GAME_CONFIG.hp.player,
        
        state: 'stand',
        stateTime: 0,
        frame: 0,
        frameTime: 0,
        
        jumping: false,
        jumpHeld: false,
        coyoteTime: 0,
        jumpBufferTime: 0,
        
        attacking: false,
        attackType: null,
        attackFrame: 0,
        attackTime: 0,
        attackHits: [], // Track enemies hit by current attack
        
        fireState: null,
        fireTime: 0,
        fireCooldown: 0,
        fireTickTime: 0,
        fireDamageCount: 0,
        
        tailActive: false,
        tailTime: 0,
        
        hurtTime: 0,
        invulnerable: 0
    },
    
    boss: null,
    enemies: [],
    projectiles: [],
    obstacles: [],
    explosions: [],  // Track active explosions
    
    camera: {
        x: 0,
        y: 0
    },
    
    spawn: {
        timers: {},
        obstacleTimer: 0,
        gateReached: false,
        enemiesFinished: false,
        obstaclesFinished: false,
        lastEnemyClearedX: 0  // Track where player was when last enemy left screen
    },
    
    keys: {
        left: false,
        right: false,
        up: false,
        down: false,
        z: false,
        x: false,
        space: false,
        spacePressed: false  // Track if space was just pressed (not held)
    },
    
    debug: false
};

// Check for debug mode in querystring
const urlParams = new URLSearchParams(window.location.search);
if (urlParams.get('debug') === 'true') {
    game.debug = true;
    document.body.classList.add('debug-mode');
}

// Physics calculations
function calculatePhysics() {
    const scale = ANCHORS_JSON.scale;
    const playerHeight = 128 * scale; // Base height (already scaled in sprite sheet)
    const targetApex = playerHeight * GAME_CONFIG.physics.targetApexFactor;
    const timeToApex = GAME_CONFIG.physics.timeToApexMs / 1000;
    
    // v = u + at, at apex v = 0, so u = -at = gt
    // s = ut + 0.5at^2, so apex = gt^2 - 0.5gt^2 = 0.5gt^2
    // Therefore g = 2*apex/t^2
    const gravity = (2 * targetApex) / (timeToApex * timeToApex);
    const jumpVel = gravity * timeToApex;
    
    return { gravity, jumpVel, targetApex };
}

const physics = calculatePhysics();

// Input handling
document.addEventListener('keydown', (e) => {
    switch(e.key.toLowerCase()) {
        case 'arrowleft': game.keys.left = true; e.preventDefault(); break;
        case 'arrowright': game.keys.right = true; e.preventDefault(); break;
        case 'arrowup': game.keys.up = true; e.preventDefault(); break;
        case 'arrowdown': game.keys.down = true; e.preventDefault(); break;
        case 'c': game.keys.down = true; e.preventDefault(); break; // 'c' also ducks
        case 'z': game.keys.z = true; e.preventDefault(); break;
        case 'x': game.keys.x = true; e.preventDefault(); break;
        case ' ': 
            if (!game.keys.space) {  // Only set spacePressed on initial press
                game.keys.spacePressed = true;
            }
            game.keys.space = true; 
            e.preventDefault(); 
            break;
        case 'd': game.debug = !game.debug; toggleDebug(); break;
    }
});

document.addEventListener('keyup', (e) => {
    switch(e.key.toLowerCase()) {
        case 'arrowleft': game.keys.left = false; break;
        case 'arrowright': game.keys.right = false; break;
        case 'arrowup': game.keys.up = false; break;
        case 'arrowdown': game.keys.down = false; break;
        case 'c': game.keys.down = false; break; // Release duck when 'c' is released
        case 'z': game.keys.z = false; break;
        case 'x': game.keys.x = false; break;
        case ' ': 
            game.keys.space = false; 
            game.keys.spacePressed = false;
            break;
    }
});

// AABB collision
function aabbIntersects(a, b) {
    return a.x < b.x + b.width &&
           a.x + a.width > b.x &&
           a.y < b.y + b.height &&
           a.y + a.height > b.y;
}

// Swept AABB
function sweptAABB(box, vel, obstacle, dt) {
    if (vel.x === 0 && vel.y === 0) {
        return { hit: false, time: 1, normal: { x: 0, y: 0 } };
    }
    
    const expandedBox = {
        x: obstacle.x - box.width / 2,
        y: obstacle.y - box.height / 2,
        width: obstacle.width + box.width,
        height: obstacle.height + box.height
    };
    
    const ray = {
        x: box.x + box.width / 2,
        y: box.y + box.height / 2,
        dx: vel.x * dt,
        dy: vel.y * dt
    };
    
    let tmin = 0;
    let tmax = 1;
    let normal = { x: 0, y: 0 };
    
    // X axis
    if (ray.dx !== 0) {
        const t1 = (expandedBox.x - ray.x) / ray.dx;
        const t2 = (expandedBox.x + expandedBox.width - ray.x) / ray.dx;
        
        const txmin = Math.min(t1, t2);
        const txmax = Math.max(t1, t2);
        
        if (txmin > tmin) {
            tmin = txmin;
            normal = { x: ray.dx > 0 ? -1 : 1, y: 0 };
        }
        tmax = Math.min(tmax, txmax);
    }
    
    // Y axis
    if (ray.dy !== 0) {
        const t1 = (expandedBox.y - ray.y) / ray.dy;
        const t2 = (expandedBox.y + expandedBox.height - ray.y) / ray.dy;
        
        const tymin = Math.min(t1, t2);
        const tymax = Math.max(t1, t2);
        
        if (tymin > tmin) {
            tmin = tymin;
            normal = { x: 0, y: ray.dy > 0 ? -1 : 1 };
        }
        tmax = Math.min(tmax, tymax);
    }
    
    if (tmax < tmin || tmin < 0 || tmin > 1) {
        return { hit: false, time: 1, normal: { x: 0, y: 0 } };
    }
    
    return { hit: true, time: tmin, normal };
}

// Sprite functions (getFrameInfo, applySpriteFrame) loaded from dragon-sprites.js

// Update player
function updatePlayer(dt) {
    const p = game.player;
    const speed = GAME_CONFIG.speed.base;
    
    // Update timers
    p.stateTime += dt;
    p.frameTime += dt;
    if (p.hurtTime > 0) p.hurtTime -= dt;
    if (p.invulnerable > 0) p.invulnerable -= dt;
    if (p.fireCooldown > 0) p.fireCooldown -= dt;
    
    // Movement - can move while attacking, firing, or ducking
    p.vx = 0;
    if (game.keys.left && !game.keys.right) {
        p.vx = -speed;
        p.facing = 'left';
    }
    if (game.keys.right && !game.keys.left) {
        p.vx = speed;
        p.facing = 'right';
    }
    
    // Gravity
    p.vy += physics.gravity * dt;
    p.vy = Math.min(p.vy, GAME_CONFIG.physics.terminalVy);
    
    // Jump with coyote time and buffer
    if (p.grounded) {
        p.coyoteTime = GAME_CONFIG.physics.coyoteMs / 1000;
        p.jumping = false;
    } else if (p.coyoteTime > 0) {
        p.coyoteTime -= dt;
    }
    
    if (game.keys.up) {
        if (!p.jumpHeld) {
            p.jumpBufferTime = GAME_CONFIG.physics.jumpBufferMs / 1000;
        }
        p.jumpHeld = true;
    } else {
        p.jumpHeld = false;
        if (p.jumping && p.vy < 0) {
            p.vy *= 0.5; // Cut jump when released
        }
    }
    
    if (p.jumpBufferTime > 0) {
        p.jumpBufferTime -= dt;
        if (p.coyoteTime > 0 && !p.jumping) {
            p.vy = -physics.jumpVel;
            p.jumping = true;
            p.jumpBufferTime = 0;
        }
    }
    
    // Ducking - can now duck in the air
    const wasDucking = p.state === 'duck' || p.state === 'duck_spin';
    const isDucking = game.keys.down && !p.attacking && !p.fireState && !p.tailActive;
    
    // Attack handling
    if (!p.attacking && !p.fireState && !p.tailActive) {
        if (game.keys.z) {
            p.attacking = true;
            p.attackType = 'punch';
            p.attackFrame = 0;
            p.attackTime = 0;
            p.attackHits = []; // Clear hit tracking for new attack
        } else if (game.keys.x) {
            p.attacking = true;
            p.attackType = 'kick';
            p.attackFrame = 0;
            p.attackTime = 0;
            p.attackHits = []; // Clear hit tracking for new attack
        } else if (game.keys.spacePressed) {
            // If ducking (on ground or in air), do tail spin
            if (game.keys.down) {
                p.tailActive = true;
                p.tailTime = 0;
                p.attackHits = []; // Clear hit tracking for tail attack
				if (game.debug) {
					console.log('Tail spin started');
				}
            } 
            // If not ducking and fire is ready, blow fire
            else if (p.fireCooldown <= 0) {
                p.fireState = 'windup';
                p.fireTime = 0;
                p.fireTickTime = 0;
                p.fireDamageCount = 0;
            }
            // Clear spacePressed so it doesn't trigger again
            game.keys.spacePressed = false;
        }
    }
    
    // Update attack states
    if (p.attacking) {
        p.attackTime += dt;
        const frameDuration = GAME_CONFIG.animation.frameDuration;
        p.attackFrame = Math.floor(p.attackTime / frameDuration);
        
        if (p.attackFrame >= 4) {
            p.attacking = false;
            p.attackType = null;
        }
    }
    
    if (p.tailActive) {
        p.tailTime += dt;
        // Keep tail active as long as space is held and player is ducking
        // If space is released or player stops ducking, deactivate
        if (!game.keys.space || !game.keys.down) {
			if (game.debug) {
	            console.log(`Tail deactivated: space=${game.keys.space}, down=${game.keys.down}, frame=${p.frame}`);
			}
            p.tailActive = false;
        }
    }
    
    if (p.fireState) {
        p.fireTime += dt;
        
        if (p.fireState === 'windup') {
            if (p.fireTime >= GAME_CONFIG.fire.windupMs / 1000) {
                p.fireState = 'beam';
                p.fireTime = 0;
                createFireBeam();
            }
        } else if (p.fireState === 'beam') {
            p.fireTickTime += dt;
            
            if (p.fireTickTime >= GAME_CONFIG.fire.tickMs / 1000) {
                p.fireTickTime = 0;
                if (p.fireDamageCount < 5) {
                    applyFireDamage();
                    p.fireDamageCount++;
                }
            }
            
            if (p.fireTime >= GAME_CONFIG.fire.activeMs / 1000) {
                p.fireState = null;
                p.fireCooldown = GAME_CONFIG.fire.cooldownMs / 1000;
                removeFireBeam();
            }
        }
    }
    
    // Movement with swept AABB
    const groundY = window.innerHeight * 0.9;
    const nextX = p.x + p.vx * dt;
    const nextY = p.y + p.vy * dt;
    
    // Ground collision (use current height before frame update)
    if (nextY + p.height >= groundY) {
        p.y = groundY - p.height;
        p.vy = 0;
        p.grounded = true;
    } else {
        p.y = nextY;
        p.grounded = false;
    }
    
    // Check obstacle (rock) collisions for movement blocking
    let finalX = nextX;
    const nextPlayerBox = {
        x: nextX,
        y: p.y,
        width: p.width,
        height: p.height
    };
    
    for (let obstacle of game.obstacles) {
        const obstacleBox = {
            x: obstacle.x,
            y: obstacle.y,
            width: obstacle.width,
            height: obstacle.height
        };
        
        if (aabbIntersects(nextPlayerBox, obstacleBox)) {
            // Block movement - keep player at current position
            finalX = p.x;
            break;
        }
    }
    
    p.x = Math.max(0, finalX);
    
    // State determination - prioritize actions over movement
    // Jump state removed - use current action while in air
    let newState = 'stand';
    if (p.hurtTime > 0) {
        newState = 'hurt';
    } else if (p.fireState === 'windup') {
        newState = 'fire_windup';
    } else if (p.fireState === 'beam') {
        newState = 'fire_beam';
    } else if (p.tailActive) {
        newState = 'duck_spin';
    } else if (p.attacking) {
        newState = p.attackType;
    } else if (game.keys.down) {
        newState = 'duck';
    } else if (Math.abs(p.vx) > 0) {
        newState = 'walk';
    }
    // Note: No separate jump state - actions (punch, kick, etc) continue while airborne
    
    // Frame animation
    if (newState !== p.state) {
        p.state = newState;
        p.frame = 0;
        p.frameTime = 0;
		if (game.debug) {
        	console.log(`State changed to: ${newState}, Frame: 0`);
		}
    } else if (p.frameTime > GAME_CONFIG.animation.frameDuration) {
        p.frameTime = 0;
        
        // Get the number of frames for this state
        const actorData = ANCHORS_JSON['dragon1'];
        const stateData = actorData?.states[p.state];
        const frameCount = stateData?.frames?.length || 1;
        
        // Loop back to frame 0 after the last frame
        const oldFrame = p.frame;
        p.frame = (p.frame + 1) % frameCount;
		if (game.debug) {
        	console.log(`State: ${p.state}, Frame: ${oldFrame} â†’ ${p.frame} (${frameCount} total frames)`);
		}
        
        // Clear attack hits when tail spin animation loops back to frame 0
        // This allows continuous damage on each loop
        if (p.frame === 0 && p.state === 'duck_spin') {
            p.attackHits = [];
            if (game.debug) {
                console.log('Tail spin looped - cleared attackHits for new damage cycle');
            }
        }
    }
    
    // Update size based on current state and frame (AFTER state is determined)
    // When punching, use the lower body dimensions (walking or stand state)
    let sizeState = p.state;
    if (p.attacking && p.attackType === 'punch') {
        sizeState = Math.abs(p.vx) > 0 ? 'walk' : 'stand';
    }
    
    const frameInfo = getFrameInfo('dragon1', sizeState, p.frame);
    if (frameInfo) {
        p.width = frameInfo.width;
        p.height = frameInfo.height; // This will be 128px (base height) when punching
    }
    
    // Update data attributes
    const dragon1El = document.getElementById('dragon1');
    dragon1El.setAttribute('data-upper', p.attacking ? p.attackType : p.state);
    dragon1El.setAttribute('data-lower', p.state);
    dragon1El.setAttribute('data-facing', p.facing);
    dragon1El.setAttribute('data-frame', p.frame);
    dragon1El.setAttribute('data-attack', p.attackType || 'none');
    dragon1El.setAttribute('data-can-fire', p.fireCooldown <= 0 ? 'true' : 'false');
}

// Create fire beam
function createFireBeam() {
    const p = game.player;
    const frameInfo = getFrameInfo('dragon1', p.state, p.frame);
    if (!frameInfo || !frameInfo.mouth) return;
    
    const scale = ANCHORS_JSON.scale;
    const actorData = ANCHORS_JSON.dragon1;
    const beam = document.createElement('div');
    beam.className = 'fire-beam projectile sprite';
    beam.id = 'player-fire-beam';
    
    const beamWidth = actorData.fire.beamSize.w * scale;
    const beamHeight = actorData.fire.beamSize.h * scale;
    
    beam.style.width = beamWidth + 'px';
    beam.style.height = beamHeight + 'px';
    
    // Apply sprite from dragon1.png
    beam.style.backgroundImage = `url('${actorData.spriteSheet.src}')`;
    const bgWidth = actorData.spriteSheet.w * scale;
    const bgHeight = actorData.spriteSheet.h * scale;
    beam.style.backgroundSize = `${bgWidth}px ${bgHeight}px`;
    beam.style.imageRendering = 'pixelated';
    
    // Initialize beam animation
    beam._frame = 0;
    beam._frameTime = 0;
    beam._totalFrames = 4; // Fire beam has 4 frames
    
    // Position based on mouth anchor using shared logic
    const groundY = window.innerHeight * 0.9;
    const position = calculateFireBeamPosition(
        p,
        beamWidth,
        beamHeight,
        game.camera.x,
        groundY,
        window.innerHeight
    );
    
    beam.style.left = position.left;
    beam.style.bottom = position.bottom;
    beam.style.transform = position.transform;
    
    beam.setAttribute('data-type', 'fire');
    beam.setAttribute('data-frame', '0');
    beam.setAttribute('data-active', 'true');
    
    document.getElementById('world').appendChild(beam);
    
    // Store the beam's world position for collision detection
    const mouthY = p.y + 55; // mouthOffsetFromTop
    let mouthX;
    if (p.facing === 'right') {
        mouthX = p.x + p.width + 20; // mouthOffsetFromRight
    } else {
        mouthX = p.x;
    }
    beam._worldX = p.facing === 'right' ? mouthX : mouthX - beamWidth;
    beam._worldY = mouthY - beamHeight/2;
    
    // Set initial frame
    updateFireBeamFrame(beam);
}

function removeFireBeam() {
    const beam = document.getElementById('player-fire-beam');
    if (beam) beam.remove();
}

function updateFireBeamFrame(beam) {
    if (!beam) return;
    
    // Fire beam sprite offsets - 4 frames at Y=566, spaced 216px apart horizontally
    const frameOffsets = [
        { x: 468, y: 566 },  // Frame 0
        { x: 688, y: 566 },  // Frame 1 (468 + 216)
        { x: 468, y: 566 },  // Frame 2 (684 + 216)
        { x: 688, y: 566 }   // Frame 3 (loop back to frame 0)
    ];
    
    const currentFrame = beam._frame % 4;
    const offset = frameOffsets[currentFrame];
    
    beam.style.backgroundPosition = `-${offset.x}px -${offset.y}px`;
    beam.setAttribute('data-frame', currentFrame);
}

function applyFireDamage() {
    const beam = document.getElementById('player-fire-beam');
    if (!beam) return;
    
    const beamRect = beam.getBoundingClientRect();
    const beamBox = {
        x: beamRect.left,
        y: beamRect.top,
        width: beamRect.width,
        height: beamRect.height
    };
    
    // Check enemies
    game.enemies.forEach(enemy => {
        const enemyRect = enemy.element.getBoundingClientRect();
        const enemyBox = {
            x: enemyRect.left,
            y: enemyRect.top,
            width: enemyRect.width,
            height: enemyRect.height
        };
        
        if (aabbIntersects(beamBox, enemyBox)) {
            enemy.hp -= 1;
            if (enemy.hp <= 0) {
                enemy.dead = true;
            } else if (enemy.type === 'rock' && enemy.hp <= 3) {
                enemy.element.classList.add('broken');
            }
        }
    });
    
    // Check boss
    if (game.boss && !game.boss.dead) {
        const bossRect = document.getElementById('dragon2').getBoundingClientRect();
        const bossBox = {
            x: bossRect.left,
            y: bossRect.top,
            width: bossRect.width,
            height: bossRect.height
        };
        
        if (aabbIntersects(beamBox, bossBox)) {
            game.boss.hp -= 1;
            game.boss.hurtTime = 0.3;
            // Spawn explosion at boss center when damaged by fire beam
            spawnExplosion(game.boss.x + game.boss.width / 2, game.boss.y + game.boss.height / 2);
        }
    }
}

// Spawn enemies
function spawnEnemy(type) {
    if (game.enemies.length >= GAME_CONFIG.spawn.maxEnemies) return;
    if (game.spawn.gateReached) return;
    
    const spawnX = game.camera.x + window.innerWidth + 50;
    const minSpacing = game.player.width;
    
    // Check spacing with other enemies
    for (let enemy of game.enemies) {
        if (Math.abs(enemy.x - spawnX) < minSpacing) return;
    }
    
    const enemy = {
        type: type,
        x: spawnX,
        y: window.innerHeight * 0.9 - 60,
        vx: -50,
        vy: 0,
        width: 50,
        height: 50,
        hp: GAME_CONFIG.hp[type] || 1,
        dead: false,
        element: null
    };
    
    if (type === 'bird') {
        enemy.width = 42;
        enemy.height = 30;
        // Spawn birds between ground level and max dragon jump height
        // Y coordinate system: higher values = closer to ground
        const groundY = window.innerHeight * 0.9;
        const minBirdY = groundY - physics.targetApex - enemy.height; // Highest point (max jump)
        const maxBirdY = groundY - enemy.height; // Ground level
        enemy.y = minBirdY + Math.random() * (maxBirdY - minBirdY);
        enemy.vx = -80;
        enemy.state = 'fly';
        enemy.frame = 0;
        enemy.frameTime = 0;
    } else if (type === 'tank') {
        enemy.width = 64;
        enemy.height = 40;
        enemy.shootCooldown = 2;
		enemy.y = window.innerHeight * 0.9 - enemy.height;
    }
    
    // Create element
    const el = document.createElement('div');
    el.className = `enemy ${type} sprite`;
    el.style.width = enemy.width + 'px';
    el.style.height = enemy.height + 'px';
    el.setAttribute('data-type', type);
    el.setAttribute('data-frame', '0');
    el.setAttribute('data-active', 'true');
    
    // Apply initial sprite frame for birds
    if (type === 'bird') {
        applySpriteFrame(el, 'bird', 'fly', 0, 'left');
    }
    
    enemy.element = el;
    document.getElementById('world').appendChild(el);
    game.enemies.push(enemy);
}

// Spawn obstacles (rocks)
function spawnObstacle() {
    if (game.obstacles.length >= GAME_CONFIG.spawn.maxObstacles) return;
    if (game.spawn.gateReached) return;
    
    const spawnX = game.camera.x + window.innerWidth + 50;
    const minSpacing = game.player.width;
    
    // Check spacing with other obstacles
    for (let obstacle of game.obstacles) {
        if (Math.abs(obstacle.x - spawnX) < minSpacing) return;
    }
    
    // Check spacing with enemies too
    for (let enemy of game.enemies) {
        if (Math.abs(enemy.x - spawnX) < minSpacing) return;
    }
    
    const obstacle = {
        type: 'rock',
        x: spawnX,
        vx: 0, // Rocks don't move
        vy: 0,
        width: 64,
        height: 96,
        hp: GAME_CONFIG.hp.rock,
        dead: false,
        element: null
    };
    
    obstacle.y = window.innerHeight * 0.9 - obstacle.height; // On the ground
    
    // Create element
    const el = document.createElement('div');
    el.className = 'obstacle rock sprite';
    el.style.width = obstacle.width + 'px';
    el.style.height = obstacle.height + 'px';
    el.setAttribute('data-type', 'rock');
    el.setAttribute('data-frame', '0');
    el.setAttribute('data-active', 'true');
    
    obstacle.element = el;
    document.getElementById('world').appendChild(el);
    game.obstacles.push(obstacle);
}

// Update enemies
function updateEnemies(dt) {
    game.enemies = game.enemies.filter(enemy => {
        if (enemy.dead) {
            enemy.element.remove();
            return false;
        }
        
        // Movement (rocks don't move)
        if (enemy.type !== 'rock') {
            enemy.x += enemy.vx * dt;
        }
        
        if (enemy.type === 'bird') {
            enemy.y += Math.sin(game.time * 3) * 150 * dt;
            
            // Animate bird frames
            enemy.frameTime += dt;
            if (enemy.frameTime >= GAME_CONFIG.animation.frameDuration) {
                enemy.frameTime = 0;
                const frameCount = getFrameCount('bird', 'fly');
                enemy.frame = (enemy.frame + 1) % frameCount;
                applySpriteFrame(enemy.element, 'bird', 'fly', enemy.frame, 'left');
            }
        } else if (enemy.type === 'tank') {
            enemy.shootCooldown -= dt;
            if (enemy.shootCooldown <= 0) {
                shootBullet(enemy);
                enemy.shootCooldown = 2;
            }
        }
        
        // Check if off-screen
        if (enemy.x < game.camera.x - 100) {
            enemy.element.remove();
            return false;
        }
        
        // Update position
        const groundY = window.innerHeight * 0.9;
        const groundHeight = window.innerHeight * 0.1;
        enemy.element.style.left = (enemy.x - game.camera.x) + 'px';
        enemy.element.style.bottom = (groundHeight + groundY - enemy.y - enemy.height) + 'px';
        
        return true;
    });
}

// Update obstacles
function updateObstacles(dt) {
    game.obstacles = game.obstacles.filter(obstacle => {
        if (obstacle.dead) {
            obstacle.element.remove();
            return false;
        }
        
        // Obstacles don't move
        
        // Check if off-screen
        if (obstacle.x < game.camera.x - 100) {
            obstacle.element.remove();
            return false;
        }
        
        // Update position
        const groundY = window.innerHeight * 0.9;
        const groundHeight = window.innerHeight * 0.1;
        obstacle.element.style.left = (obstacle.x - game.camera.x) + 'px';
        obstacle.element.style.bottom = (groundHeight + groundY - obstacle.y - obstacle.height) + 'px';
        
        return true;
    });
}

function shootBullet(tank) {
    const bullet = {
        x: tank.x - 20,
        y: tank.y + (tank.height/2)-10,
        vx: -200,
        vy: 0,
        width: 12,
        height: 6,
        element: null
    };
    
    const el = document.createElement('div');
    el.className = 'bullet projectile sprite';
    el.setAttribute('data-type', 'bullet');
    el.setAttribute('data-frame', '0');
    el.setAttribute('data-active', 'true');
    
    bullet.element = el;
    document.getElementById('world').appendChild(el);
    game.projectiles.push(bullet);
}

// Update projectiles
function updateProjectiles(dt) {
    game.projectiles = game.projectiles.filter(proj => {
        proj.x += proj.vx * dt;
        proj.y += proj.vy * dt;
        
        if (proj.x < game.camera.x - 100 || proj.x > game.camera.x + window.innerWidth + 100) {
            proj.element.remove();
            return false;
        }
        
        // Position projectiles
        const groundY = window.innerHeight * 0.9;
        const groundHeight = window.innerHeight * 0.1;
        proj.element.style.left = (proj.x - game.camera.x) + 'px';
        proj.element.style.bottom = (groundHeight + groundY - proj.y - proj.height) + 'px';
        
        return true;
    });
}

// Explosion system
function spawnExplosion(x, y) {
    const explosion = {
        x: x,
        y: y,
        frame: 0,
        frameTime: 0,
        element: null
    };
    
    const el = document.createElement('div');
    el.className = 'explosion sprite';
    el.style.position = 'absolute';
    el.style.zIndex = '20'; // Above everything else
    
    // Apply initial frame
    applySpriteFrame(el, 'explosion', 'explode', 0);
    
    explosion.element = el;
    document.getElementById('world').appendChild(el);
    game.explosions.push(explosion);
    
    // Position explosion
    const groundY = window.innerHeight * 0.9;
    const groundHeight = window.innerHeight * 0.1;
    const frameInfo = getFrameInfo('explosion', 'explode', 0);
    el.style.left = (x - game.camera.x - frameInfo.width / 2) + 'px';
    el.style.bottom = (groundHeight + groundY - y - frameInfo.height / 2) + 'px';
}

function updateExplosions(dt) {
    game.explosions = game.explosions.filter(explosion => {
        explosion.frameTime += dt;
        
        if (explosion.frameTime >= GAME_CONFIG.animation.frameDuration) {
            explosion.frameTime = 0;
            explosion.frame++;
            
            const frameCount = getFrameCount('explosion', 'explode');
            if (explosion.frame >= frameCount) {
                // Animation complete, remove explosion
                explosion.element.remove();
                return false;
            }
            
            // Update to next frame
            applySpriteFrame(explosion.element, 'explosion', 'explode', explosion.frame);
            
            // Update size and position as frame size changes
            const frameInfo = getFrameInfo('explosion', 'explode', explosion.frame);
            const groundY = window.innerHeight * 0.9;
            const groundHeight = window.innerHeight * 0.1;
            explosion.element.style.left = (explosion.x - game.camera.x - frameInfo.width / 2) + 'px';
            explosion.element.style.bottom = (groundHeight + groundY - explosion.y - frameInfo.height / 2) + 'px';
        }
        
        return true;
    });
}

// Boss logic
function spawnBoss() {
    game.boss = {
        x: game.camera.x + window.innerWidth - 200,
        y: window.innerHeight * 0.4,
        vx: 0,
        vy: 0,
        width: 240,
        height: 220,
        hp: GAME_CONFIG.hp.boss,
        maxHp: GAME_CONFIG.hp.boss,
        state: 'fly',
        frame: 0,
        frameTime: 0,
        lightningCooldown: 0,
        hurtTime: 0,
        dead: false,
        pattern: 'hover'
    };
    
    const el = document.createElement('div');
    el.id = 'dragon2';
    el.className = 'sprite';
    el.style.width = game.boss.width + 'px';
    el.style.height = game.boss.height + 'px';
    el.setAttribute('data-state', 'fly');
    el.setAttribute('data-frame', '0');
    el.setAttribute('data-attack', 'none');
    
    document.getElementById('world').appendChild(el);
    document.getElementById('boss-health').style.display = 'block';
}

function updateBoss(dt) {
    if (!game.boss || game.boss.dead) return;
    
    const b = game.boss;
    b.frameTime += dt;
    
    if (b.hurtTime > 0) {
        b.hurtTime -= dt;
        b.state = 'hurt';
    } else {
        b.state = 'fly';
    }
    
    // Movement pattern
    b.y += Math.sin(game.time * 2) * 30 * dt;
    b.x += Math.cos(game.time * 1.5) * 20 * dt;
    
    // Lightning attack
    b.lightningCooldown -= dt;
    if (b.lightningCooldown <= 0) {
        shootLightning();
        b.lightningCooldown = ANCHORS_JSON.dragon2.lightning.cooldownMs / 1000;
    }
    
    // Animation
    if (b.frameTime > GAME_CONFIG.animation.frameDuration) {
        b.frameTime = 0;
        b.frame = (b.frame + 1) % 12;
    }
    
    // Check death
    if (b.hp <= 0) {
        b.dead = true;
        b.state = 'dead';
        b.vy = 300;
        gameWin();
    }
    
    // Update element
    const el = document.getElementById('dragon2');
    if (el) {
        applySpriteFrame(el, 'dragon2', b.state, b.frame, 'left');
        el.style.left = (b.x - game.camera.x) + 'px';
        el.style.bottom = (window.innerHeight - b.y - b.height) + 'px';
        el.setAttribute('data-state', b.state);
        el.setAttribute('data-frame', b.frame);
    }
    
    // Update health bar
    const healthPct = Math.max(0, b.hp / b.maxHp * 100);
    document.getElementById('boss-health-fill').style.width = healthPct + '%';
}

function shootLightning() {
    const b = game.boss;
    const bolt = {
        x: b.x + 50,
        y: b.y + b.height - 50,
        vx: game.player.x > b.x ? 300 : -300,
        vy: 100,
        width: 160,
        height: 48,
        element: null
    };
    
    const el = document.createElement('div');
    el.className = 'lightning-bolt projectile sprite';
    el.setAttribute('data-type', 'lightning');
    el.setAttribute('data-frame', '0');
    el.setAttribute('data-active', 'true');
    
    bolt.element = el;
    document.getElementById('world').appendChild(el);
    game.projectiles.push(bolt);
}

// Collision detection
function checkCollisions() {
    const p = game.player;
    
    // Get player hitbox/hurtbox
    const playerBox = {
        x: p.x,
        y: p.y,
        width: p.width,
        height: p.height
    };
    
    if (p.state === 'duck' || p.state === 'duck_spin') {
        playerBox.height *= 0.75;
        playerBox.y += p.height * 0.25;
        
        // Adjust x position for duck offset to match visual position
        const frameInfo = getFrameInfo('dragon1', p.state, p.frame);
        if (frameInfo) {
            // Apply correct offset based on facing direction
            if (p.facing === 'right' && frameInfo.duckOffset) {
                playerBox.x += frameInfo.duckOffset;
            } else if (p.facing === 'left' && frameInfo.duckOffsetLeft) {
                playerBox.x += frameInfo.duckOffsetLeft;
            }
        }
    }
    
    // Adjust x position for kick offset when kicking and facing left
    if (p.state === 'kick' && p.facing === 'left') {
        const frameInfo = getFrameInfo('dragon1', p.state, p.frame);
        if (frameInfo && frameInfo.kickOffset) {
            playerBox.x += frameInfo.kickOffset;
        }
    }
    
    // Check if player is attacking
    const isAttacking = p.attacking || p.tailActive || p.fireState === 'beam';
    const isPunching = p.attacking && p.attackType === 'punch';
    
    // Create punch hitbox if punching (upper body area)
    let punchHitbox = null;
    if (isPunching) {
        // Upper body punch hitbox - positioned at the upper 64px of the player
        const punchWidth = 142;
        const punchHeight = 64;
        const punchReach = p.facing === 'right' ? 30 : -30; // Extend hitbox in facing direction
        
        punchHitbox = {
            x: p.facing === 'right' ? p.x + punchReach : p.x - punchWidth + punchReach,
            y: p.y, // Upper portion of sprite
            width: punchWidth,
            height: punchHeight
        };
    }
    
    // Enemy collisions
    game.enemies.forEach(enemy => {
        const enemyBox = {
            x: enemy.x,
            y: enemy.y,
            width: enemy.width,
            height: enemy.height
        };
        
        // Check punch hitbox first
        let punchHit = false;
        if (punchHitbox && aabbIntersects(punchHitbox, enemyBox)) {
            // Only damage if this enemy hasn't been hit by this attack yet
            if (!p.attackHits.includes(enemy)) {
                punchHit = true;
                p.attackHits.push(enemy); // Mark as hit
                enemy.hp -= GAME_CONFIG.damage.punch;
                if (enemy.hp <= 0) {
                    enemy.dead = true;
                    // Spawn explosion at enemy center (not rocks)
                    if (enemy.type !== 'rock') {
                        const explosionX = enemy.x + enemy.width / 2;
                        const explosionY = enemy.y + enemy.height / 2;
                        spawnExplosion(explosionX, explosionY);
                    }
                } else if (enemy.type === 'rock' && enemy.hp <= 3) {
                    enemy.element.classList.add('broken');
                }
            }
        }
        
        // Regular body collision (only if not already hit by punch)
        if (!punchHit && aabbIntersects(playerBox, enemyBox)) {
            // Check if player is doing any damaging action
            const isDucking = p.state === 'duck' || p.state === 'duck_spin';
            if ((isAttacking && !isPunching) || isDucking) {
                // Only damage if this enemy hasn't been hit by this attack yet
                if (!p.attackHits.includes(enemy)) {
                    // Debug logging for tail
                    if (p.tailActive && enemy.type === 'rock' && game.debug) {
                        console.log('Tail collision with rock:', {
                            tailActive: p.tailActive,
                            state: p.state,
                            isDucking: isDucking,
                            isAttacking: isAttacking,
                            enemyHP: enemy.hp,
                            damage: GAME_CONFIG.damage.tail
                        });
                    }
                    
                    // Any attack or duck_spin damages enemies (including rocks)
                    let damage = 0;
                    if (p.tailActive || p.state === 'duck_spin') {
                        damage = GAME_CONFIG.damage.tail;
                    } else if (p.attacking) {
                        damage = p.attackType === 'kick' ? 2 : 1;
                    }
                    
                    if (damage > 0) {
                        p.attackHits.push(enemy); // Mark as hit
                        enemy.hp -= damage;
                        if (enemy.hp <= 0) {
                            enemy.dead = true;
                            // Spawn explosion at enemy center (not rocks)
                            if (enemy.type !== 'rock') {
                                const explosionX = enemy.x + enemy.width / 2;
                                const explosionY = enemy.y + enemy.height / 2;
                                spawnExplosion(explosionX, explosionY);
                            }
                        } else if (enemy.type === 'rock' && enemy.hp <= 3) {
                            enemy.element.classList.add('broken');
                        }
                    }
                }
            } else if (p.invulnerable <= 0 && !isAttacking && !isDucking) {
                // Contact damage to player (not rocks)
                if (enemy.type !== 'rock') {
                    const damage = enemy.type === 'bird' ? 1 : 2;
                    p.hp -= damage;
                    p.hurtTime = 0.5;
                    p.invulnerable = 1;
                    
                    // Spawn explosion at collision center
                    const collisionX = Math.max(playerBox.x, enemyBox.x);
                    const collisionRight = Math.min(playerBox.x + playerBox.width, enemyBox.x + enemyBox.width);
                    const collisionY = Math.max(playerBox.y, enemyBox.y);
                    const collisionBottom = Math.min(playerBox.y + playerBox.height, enemyBox.y + enemyBox.height);
                    const explosionX = (collisionX + collisionRight) / 2;
                    const explosionY = (collisionY + collisionBottom) / 2;
                    spawnExplosion(explosionX, explosionY);
                }
                // Rocks block movement - this is handled in updatePlayer
            }
        }
    });
    
    // Obstacle collisions
    game.obstacles.forEach(obstacle => {
        const obstacleBox = {
            x: obstacle.x,
            y: obstacle.y,
            width: obstacle.width,
            height: obstacle.height
        };
        
        // Check punch hitbox first
        let punchHit = false;
        if (punchHitbox && aabbIntersects(punchHitbox, obstacleBox)) {
            // Only damage if this obstacle hasn't been hit by this attack yet
            if (!p.attackHits.includes(obstacle)) {
                punchHit = true;
                p.attackHits.push(obstacle); // Mark as hit
                obstacle.hp -= GAME_CONFIG.damage.punch;
                if (obstacle.hp <= 0) {
                    obstacle.dead = true;
                } else if (obstacle.hp <= 3) {
                    obstacle.element.classList.add('broken');
                }
            }
        }
        
        // Regular body collision (only if not already hit by punch)
        if (!punchHit && aabbIntersects(playerBox, obstacleBox)) {
            // Check if player is doing any damaging action
            const isDucking = p.state === 'duck' || p.state === 'duck_spin';
            if ((isAttacking && !isPunching) || isDucking) {
                // Only damage if this obstacle hasn't been hit by this attack yet
                if (!p.attackHits.includes(obstacle)) {
                    // Any attack or duck_spin damages obstacles
                    let damage = 0;
                    if (p.tailActive || p.state === 'duck_spin') {
                        damage = GAME_CONFIG.damage.tail;
                    } else if (p.attacking) {
                        damage = p.attackType === 'kick' ? 2 : 1;
                    }
                    
                    if (damage > 0) {
                        p.attackHits.push(obstacle); // Mark as hit
                        obstacle.hp -= damage;
                        if (obstacle.hp <= 0) {
                            obstacle.dead = true;
                        } else if (obstacle.hp <= 3) {
                            obstacle.element.classList.add('broken');
                        }
                    }
                }
            }
        }
    });
    
    // Fire beam collisions
    const fireBeam = document.getElementById('player-fire-beam');
    if (fireBeam && fireBeam._worldX !== undefined) {
        const beamBox = {
            x: fireBeam._worldX,
            y: fireBeam._worldY,
            width: 216,
            height: 102
        };
        
        // Check fire beam vs enemies
        game.enemies.forEach(enemy => {
            if (enemy.dead) return;
            const enemyBox = {
                x: enemy.x,
                y: enemy.y,
                width: enemy.width,
                height: enemy.height
            };
            if (aabbIntersects(beamBox, enemyBox)) {
                enemy.hp -= GAME_CONFIG.damage.fire * (game.fixedDeltaMs / 1000);
                if (enemy.hp <= 0) {
                    enemy.dead = true;
                    // Spawn explosion at enemy center (not for rocks)
                    if (enemy.type !== 'rock') {
                        spawnExplosion(enemy.x + enemy.width / 2, enemy.y + enemy.height / 2);
                    }
                } else if (enemy.type === 'rock' && enemy.hp <= 3) {
                    enemy.element.classList.add('broken');
                }
            }
        });
        
        // Check fire beam vs obstacles
        game.obstacles.forEach(obstacle => {
            if (obstacle.dead) return;
            const obstacleBox = {
                x: obstacle.x,
                y: obstacle.y,
                width: obstacle.width,
                height: obstacle.height
            };
            if (aabbIntersects(beamBox, obstacleBox)) {
                obstacle.hp -= GAME_CONFIG.damage.fire * (game.fixedDeltaMs / 1000);
                if (obstacle.hp <= 0) {
                    obstacle.dead = true;
                } else if (obstacle.hp <= 3) {
                    obstacle.element.classList.add('broken');
                }
            }
        });
    }
    
    // Projectile collisions
    game.projectiles.forEach(proj => {
        const projBox = {
            x: proj.x,
            y: proj.y,
            width: proj.width,
            height: proj.height
        };
        
        if (aabbIntersects(playerBox, projBox) && p.invulnerable <= 0) {
            const damage = proj.element.classList.contains('lightning-bolt') ? 4 : 2;
            p.hp -= damage;
            p.hurtTime = 0.5;
            p.invulnerable = 1;
            
            // Spawn explosion at projectile impact center
            const collisionX = Math.max(playerBox.x, projBox.x);
            const collisionRight = Math.min(playerBox.x + playerBox.width, projBox.x + projBox.width);
            const collisionY = Math.max(playerBox.y, projBox.y);
            const collisionBottom = Math.min(playerBox.y + playerBox.height, projBox.y + projBox.height);
            const explosionX = (collisionX + collisionRight) / 2;
            const explosionY = (collisionY + collisionBottom) / 2;
            spawnExplosion(explosionX, explosionY);
            
            proj.element.remove();
            game.projectiles = game.projectiles.filter(pr => pr !== proj);
        }
    });
    
    // Boss collision
    if (game.boss && !game.boss.dead) {
        const bossBox = {
            x: game.boss.x,
            y: game.boss.y,
            width: game.boss.width,
            height: game.boss.height
        };
        
        // Check punch hitbox first
        let punchHitBoss = false;
        if (punchHitbox && aabbIntersects(punchHitbox, bossBox)) {
            punchHitBoss = true;
            game.boss.hp -= GAME_CONFIG.damage.punch;
            game.boss.hurtTime = 0.3;
            // Spawn explosion at boss center when damaged
            spawnExplosion(game.boss.x + game.boss.width / 2, game.boss.y + game.boss.height / 2);
        }
        
        // Regular body collision (only if not already hit by punch)
        if (!punchHitBoss && aabbIntersects(playerBox, bossBox)) {
            const isDucking = p.state === 'duck' || p.state === 'duck_spin';
            if ((isAttacking && !isPunching) || isDucking) {
                // Attack or duck_spin damages boss
                if (p.tailActive || p.state === 'duck_spin') {
                    game.boss.hp -= GAME_CONFIG.damage.tail;
                    game.boss.hurtTime = 0.3;
                    // Spawn explosion at boss center when damaged by tail
                    spawnExplosion(game.boss.x + game.boss.width / 2, game.boss.y + game.boss.height / 2);
                } else if (p.attacking) {
                    const damage = p.attackType === 'kick' ? 2 : 1;
                    game.boss.hp -= damage;
                    game.boss.hurtTime = 0.3;
                    // Spawn explosion at boss center when damaged by attack
                    spawnExplosion(game.boss.x + game.boss.width / 2, game.boss.y + game.boss.height / 2);
                }
            } else if (p.invulnerable <= 0 && !isAttacking && !isDucking) {
                p.hp -= 1;
                p.hurtTime = 0.5;
                p.invulnerable = 1;
                p.vx = p.x < game.boss.x ? -200 : 200;
                // Spawn explosion at collision center when player hit by boss
                const overlapLeft = Math.max(playerBox.x, bossBox.x);
                const overlapRight = Math.min(playerBox.x + playerBox.width, bossBox.x + bossBox.width);
                const overlapTop = Math.max(playerBox.y, bossBox.y);
                const overlapBottom = Math.min(playerBox.y + playerBox.height, bossBox.y + bossBox.height);
                const explosionX = (overlapLeft + overlapRight) / 2;
                const explosionY = (overlapTop + overlapBottom) / 2;
                spawnExplosion(explosionX, explosionY);
            }
        }
    }
    
    // Check player death
    if (p.hp <= 0 && !game.lost) {
        gameLose();
    }
}

// Camera update
function updateCamera() {
    const p = game.player;
    const targetX = Math.max(0, p.x - window.innerWidth/2 + GAME_CONFIG.camera.lookAheadPx);
    
    game.camera.x = targetX;
}

// Render
function render() {
    const p = game.player;
    const cam = game.camera;
    
    // Update parallax
    document.getElementById('far-mountains').style.transform = `translateX(${-cam.x * 0.3}px)`;
    document.getElementById('near-mountains').style.transform = `translateX(${-cam.x * 0.6}px)`;
    document.getElementById('ground').style.transform = `translateX(${-cam.x}px)`;
    
    // Update player sprite with frame offsets
    const dragon1 = document.getElementById('dragon1');
    const dragon1Upper = document.getElementById('dragon1-upper');
    
    // Check if we're punching - if so, render split upper/lower body
    const isPunching = p.attacking && p.attackType === 'punch';
    
    if (isPunching) {
        // Render lower body (walking state or stand)
        const lowerState = Math.abs(p.vx) > 0 ? 'walk' : 'stand';
        applySpriteFrame(dragon1, 'dragon1', lowerState, p.frame, p.facing);
        
        // Clip the top 64px of dragon1 to only show lower body
        dragon1.style.height = '64px';
        dragon1.style.overflow = 'hidden';
        
        // Get the current background position and adjust it to shift the sprite up by 64px
        // This makes the bottom 64px of the sprite visible in the 64px tall div
        const currentBgPos = dragon1.style.backgroundPosition;
        const bgPosMatch = currentBgPos.match(/-?[\d.]+px/g);
        if (bgPosMatch && bgPosMatch.length >= 2) {
            const bgX = bgPosMatch[0];
            const bgY = parseFloat(bgPosMatch[1]);
            dragon1.style.backgroundPosition = `${bgX} ${bgY - 64}px`;
        }
        
        // Render upper body (punch)
        applySpriteFrame(dragon1Upper, 'dragon1', 'punch_upper', p.attackFrame, p.facing);
        
        // Make upper body visible and position it
        dragon1Upper.style.display = 'block';
        dragon1Upper.style.width = '108px';
        dragon1Upper.style.height = '64px';
    } else {
        // Normal single-sprite rendering
        applySpriteFrame(dragon1, 'dragon1', p.state, p.frame, p.facing);
        
        // Reset dragon1 to full size based on current state
        const currentFrameInfo = getFrameInfo('dragon1', p.state, p.frame);
        if (currentFrameInfo) {
            dragon1.style.height = currentFrameInfo.height + 'px';
            dragon1.style.width = currentFrameInfo.width + 'px';
        }
        dragon1.style.overflow = 'visible';
        
        // Hide upper body
        dragon1Upper.style.display = 'none';
    }
    
    // Get duck/kick offset from frame info
    const frameInfo = getFrameInfo('dragon1', p.state, p.frame);
    let leftOffset = 0;
    
    // Apply duck offset when ducking
    if (p.state === 'duck_spin' && frameInfo && frameInfo.duckOffset) {
		if (p.facing == "right") {
			leftOffset = frameInfo.duckOffset;
		} else {
			leftOffset = frameInfo.duckOffsetLeft;
		}
    }
    
    // Apply kick offset when kicking and facing left
    if (p.state === 'kick' && p.facing === 'left' && frameInfo && frameInfo.kickOffset) {
        leftOffset = frameInfo.kickOffset;
    }
    
    // Position the player
    // groundY is at 90% of window height. Ground div is bottom 10%.
    // CSS bottom is measured from viewport bottom, so: bottom = groundHeight + (groundY - p.y - p.height)
    const groundY = window.innerHeight * 0.9;
    const groundHeight = window.innerHeight * 0.1;
    dragon1.style.left = (p.x - cam.x + leftOffset) + 'px';
    dragon1.style.bottom = (groundHeight + groundY - p.y - p.height) + 'px';
    
    // Position upper body if punching (on top of lower body)
    if (isPunching) {
		let upperBodyLeftOffset = -24;
		if (p.facing == "right") {
			upperBodyLeftOffset = 58; // Push upper to the right because tail isn't a part of it.
		}
        dragon1Upper.style.left = (p.x - cam.x + leftOffset) + upperBodyLeftOffset + 'px';
        dragon1Upper.style.bottom = (groundHeight + groundY - p.y - 64) + 'px'; // 64px from bottom of sprite
    }
    
    // Update boss sprite if exists
    if (game.boss) {
        const dragon2 = document.getElementById('dragon2');
        if (dragon2) {
            applySpriteFrame(dragon2, 'dragon2', game.boss.state, game.boss.frame, 'left');
            dragon2.style.left = (game.boss.x - cam.x) + 'px';
            // Boss uses same coordinate system as other entities
            const groundHeight = window.innerHeight * 0.1;
            dragon2.style.bottom = (groundHeight + game.boss.y) + 'px';
        }
    }
    
    // Update fire beam position if active - follows player movement
    const fireBeam = document.getElementById('player-fire-beam');
    if (fireBeam) {
        // Recalculate position based on current player position using shared logic
        const beamWidth = 216;
        const beamHeight = 102;
        const groundY = window.innerHeight * 0.9;
        
        const position = calculateFireBeamPosition(
            p,
            beamWidth,
            beamHeight,
            cam.x,
            groundY,
            window.innerHeight
        );
        
        fireBeam.style.left = position.left;
        fireBeam.style.bottom = position.bottom;
        fireBeam.style.transform = position.transform;
        
        // Update world position for collision detection
        // Calculate mouth position for collision
        const mouthY = p.y + 55; // mouthOffsetFromTop
        let mouthX;
        if (p.facing === 'right') {
            mouthX = p.x + p.width + 20; // mouthOffsetFromRight
        } else {
            mouthX = p.x;
        }
        fireBeam._worldX = p.facing === 'right' ? mouthX : mouthX - beamWidth;
        fireBeam._worldY = mouthY - beamHeight/2;
        
        // Animate fire beam frames
        const dt = game.fixedDeltaMs / 1000;
        fireBeam._frameTime += dt;
        if (fireBeam._frameTime >= GAME_CONFIG.animation.frameDuration) {
            fireBeam._frameTime = 0;
            fireBeam._frame = (fireBeam._frame + 1) % fireBeam._totalFrames;
            updateFireBeamFrame(fireBeam);
        }
    }
    
    // Update HUD
    const healthPct = Math.max(0, p.hp / p.maxHp * 100);
    document.getElementById('player-health').style.width = healthPct + '%';
    
    const cooldownPct = Math.max(0, (1 - p.fireCooldown / (GAME_CONFIG.fire.cooldownMs/1000)) * 100);
    document.getElementById('fire-cooldown').style.width = cooldownPct + '%';
}

// Spawn scheduler
function updateSpawner(dt) {
    if (game.spawn.gateReached) return;
    
    const elapsed = game.time;
    const schedule = GAME_CONFIG.spawn.schedule;
    
    // Find current phase for enemies
    let phase = null;
    for (let p of schedule) {
        if (elapsed >= p.start && elapsed < p.end) {
            phase = p;
            break;
        }
    }
    
    if (!phase) {
        // No more enemy spawning phases - mark as finished
        if (!game.spawn.enemiesFinished) {
            game.spawn.enemiesFinished = true;
            if (game.debug) {
                console.log('Enemy spawning finished at time:', elapsed);
            }
        }
    } else {
        // Update spawn timers for enemies
        phase.enemies.forEach((type, i) => {
            const key = `${type}_${i}`;
            if (!game.spawn.timers[key]) {
                game.spawn.timers[key] = 0;
            }
            
            game.spawn.timers[key] += dt;
            
            const interval = phase.intervals[i] / 1000;
            if (game.spawn.timers[key] >= interval) {
                if (game.enemies.length < phase.max) {
                    spawnEnemy(type);
                    game.spawn.timers[key] = 0;
                }
            }
        });
    }
    
    // Obstacle spawning - stop when enemy spawning stops
    if (game.spawn.enemiesFinished) {
        if (!game.spawn.obstaclesFinished) {
            game.spawn.obstaclesFinished = true;
            if (game.debug) {
                console.log('Obstacle spawning finished at time:', elapsed);
            }
        }
        return; // Stop all spawning
    }
    
    const obstacleSchedule = GAME_CONFIG.spawn.obstacleSchedule;
    let obstaclePhase = null;
    for (let p of obstacleSchedule) {
        if (elapsed >= p.start && elapsed < p.end) {
            obstaclePhase = p;
            break;
        }
    }
    
    if (obstaclePhase) {
        game.spawn.obstacleTimer += dt;
        const obstacleInterval = obstaclePhase.interval / 1000;
        if (game.spawn.obstacleTimer >= obstacleInterval) {
            spawnObstacle();
            game.spawn.obstacleTimer = 0;
        }
    }
}

// Main game loop
function gameLoop(timestamp) {
    if (!game.running) return;
    
    const deltaTime = timestamp - game.lastTime;
    game.lastTime = timestamp;
    game.accumulator += deltaTime;
    
    // Fixed timestep
    while (game.accumulator >= game.fixedDeltaMs) {
        const dt = game.fixedDeltaMs / 1000;
        game.time += dt;
        
        updatePlayer(dt);
        updateEnemies(dt);
        updateObstacles(dt);
        updateProjectiles(dt);
        updateExplosions(dt);
        updateSpawner(dt);
        
        // Check boss spawn - hybrid approach
        if (!game.boss && !game.spawn.gateReached) {
            // Check if spawning has finished
            if (game.spawn.enemiesFinished) {
                // Check if all enemies are off-screen (left side)
                const allEnemiesGone = game.enemies.length === 0 || 
                    game.enemies.every(e => e.x < game.camera.x - 100);
                
                if (allEnemiesGone) {
                    // Record where player was when last enemy cleared
                    if (game.spawn.lastEnemyClearedX === 0) {
                        game.spawn.lastEnemyClearedX = game.player.x;
                        if (game.debug) {
                            console.log('All enemies cleared at player x:', game.spawn.lastEnemyClearedX);
                        }
                    }
                    
                    // Calculate buffer distance (window width or 1000px, whichever is smaller)
                    const bufferDistance = Math.min(window.innerWidth, 1000);
                    const distanceTraveled = game.player.x - game.spawn.lastEnemyClearedX;
                    
                    // Spawn boss after buffer distance
                    if (distanceTraveled >= bufferDistance) {
                        game.spawn.gateReached = true;
                        if (game.debug) {
                            console.log('Spawning boss after buffer distance:', bufferDistance, 'traveled:', distanceTraveled);
                        }
                        spawnBoss();
                    }
                }
            }
        }
        
        if (game.boss) {
            updateBoss(dt);
        }
        
        checkCollisions();
        updateCamera();
        
        game.accumulator -= game.fixedDeltaMs;
    }
    
    render();
    
    if (game.debug) {
        updateDebug();
    }
    
    requestAnimationFrame(gameLoop);
}

function startGame() {
    document.getElementById('menu').style.display = 'none';
    
    // Reset game state
    game.running = true;
    game.won = false;
    game.lost = false;
    game.time = 0;
    game.lastTime = performance.now();
    game.accumulator = 0;
    
    game.player.hp = GAME_CONFIG.hp.player;
    game.player.x = 100;
    game.player.y = window.innerHeight * 0.9 - game.player.height; // Start at ground level
    game.player.vx = 0;
    game.player.vy = 0;
    game.player.fireCooldown = 0;
    
    game.enemies = [];
    game.obstacles = [];
    game.projectiles = [];
    game.explosions = [];
    game.boss = null;
    game.spawn.gateReached = false;
    game.spawn.enemiesFinished = false;
    game.spawn.obstaclesFinished = false;
    game.spawn.lastEnemyClearedX = 0;
    game.spawn.timers = {};
    game.spawn.obstacleTimer = 0;
    
    // Clear world
    const world = document.getElementById('world');
    world.innerHTML = '<div id="dragon1" class="sprite" data-upper="stand" data-lower="stand" data-facing="right" data-frame="0" data-attack="none" data-can-fire="true"></div><div id="dragon1-upper" class="sprite"></div>';
    
    requestAnimationFrame(gameLoop);
}

function gameWin() {
    game.won = true;
    game.running = false;
    
    const menu = document.getElementById('menu');
    menu.innerHTML = '<h1>YOU WIN!</h1><button onclick="startGame()">PLAY AGAIN</button>';
    menu.style.display = 'block';
}

function gameLose() {
    game.lost = true;
    game.running = false;
    
    const menu = document.getElementById('menu');
    menu.innerHTML = '<h1>YOU LOSE!</h1><button onclick="startGame()">RETRY?</button>';
    menu.style.display = 'block';
}

function toggleDebug() {
    document.getElementById('debug').style.display = game.debug ? 'block' : 'none';
    if (game.debug) {
        document.body.classList.add('debug-mode');
    } else {
        document.body.classList.remove('debug-mode');
    }
}

function updateDebug() {
    const p = game.player;
    const debugEl = document.getElementById('debug');
    debugEl.innerHTML = `
        Player: x=${Math.round(p.x)} y=${Math.round(p.y)}<br>
        Velocity: vx=${Math.round(p.vx)} vy=${Math.round(p.vy)}<br>
        State: ${p.state} Frame: ${p.frame}<br>
        HP: ${p.hp}/${p.maxHp}<br>
        Grounded: ${p.grounded}<br>
        Coyote: ${(p.coyoteTime * 1000).toFixed(0)}ms<br>
        Jump Buffer: ${(p.jumpBufferTime * 1000).toFixed(0)}ms<br>
        Fire CD: ${(p.fireCooldown * 1000).toFixed(0)}ms<br>
        Enemies: ${game.enemies.length}/${GAME_CONFIG.spawn.maxEnemies}<br>
        Time: ${game.time.toFixed(1)}s<br>
        Distance: ${Math.round(p.x)}/${GAME_CONFIG.level.gateX}<br>
        Target Apex: ${Math.round(physics.targetApex)}px
    `;
}

// Initialize
console.log('Dragon Side-Scroller initialized');
console.log('Physics:', physics);
console.log('Config:', GAME_CONFIG);
</script>
</body>
</html>